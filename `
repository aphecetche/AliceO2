// Copyright CERN and copyright holders of ALICE O2. This software is
// distributed under the terms of the GNU General Public License v3 (GPL
// Version 3), copied verbatim in the file "COPYING".
//
// See http://alice-o2.web.cern.ch/license for full licensing information.
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#include "UserLogicDSDecoder.h"
#include "MCHRawCommon/SampaHeader.h"

#include <boost/msm/back/state_machine.hpp>
#include <boost/msm/front/state_machine_def.hpp>
#include <boost/msm/front/functor_row.hpp>
#include <fmt/format.h>

using namespace std;
namespace msm = boost::msm;
namespace mpl = boost::mpl;
using namespace msm::front;

namespace o2::mch::raw
{

struct NewData {
  NewData(uint64_t d) : data{d} {}
  uint64_t data;
};

struct SyncNotFound {
};

// States

struct NamedState : public msm::front::state<> {
  NamedState(const char* name_) : name{name_} {}
  template <class Event, class FSM>
  void on_entry(const Event&, const FSM&)
  {
    std::cout << "entering " << name << "\n";
  }
  template <class Event, class FSM>
  void on_exit(const Event&, const FSM&)
  {
    std::cout << "leaving " << name << "\n";
  }
  std::string name;
};

struct LookingForSync : public NamedState {
  LookingForSync() : NamedState("LookingForSync") {}
};

struct LookingForHeader : public NamedState {
  LookingForHeader() : NamedState("LookingForHeader") {}
};

struct ReadingSize : public NamedState {
  ReadingSize() : NamedState("ReadingSize") {}
};

struct ReadingTime : public NamedState {
  ReadingTime() : NamedState("ReadingTime") {}
};

struct ReadingSample : public NamedState {
  ReadingSample() : NamedState("ReadingSample") {}
};

struct saveData {
  template <class EVT, class FSM, class SourceState, class TargetState>
  void operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    fsm.data = evt.data;
  }
};

// Guards
struct syncFound {
  template <class EVT, class FSM, class SourceState, class TargetState>
  bool operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    const uint64_t sync = sampaSync().uint64();
    return evt.data == sync;
  }
};

struct validHeader {
  template <class EVT, class FSM, class SourceState, class TargetState>
  bool operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    SampaHeader sh(evt.data);
    cout << "validHeader : " << evt.data << "\n";
    cout << sh << "\n";
    fsm.nof10BitWords = sh.nof10BitWords();
    return true;
  }
};

struct validSize {
  template <class EVT, class FSM, class SourceState, class TargetState>
  bool operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    auto n = fsm.data10(evt.data, fsm.maskIndex);
    std::cout << "validSize=" << n << "\n";
    return n > 0 && n < 1024;
  }
};

struct moreDataToRead {
  template <class EVT, class FSM, class SourceState, class TargetState>
  bool operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    std::cout << "moreDataToRead ? fsm.nof10BitWords = " << fsm.nof10BitWords
              << " fsm.maskIndex = " << fsm.maskIndex << "\n";
    return fsm.nof10BitWords > 0 && fsm.maskIndex < fsm.masks.size();
  }
};

// Actions

struct readSize {
  template <class EVT, class FSM, class SourceState, class TargetState>
  void operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    fsm.clusterSize = fsm.data10(fsm.data, fsm.maskIndex);
    --fsm.nof10BitWords;
    ++fsm.maskIndex;
    std::cout << "fsm.data = 0x" << std::hex << fsm.data << " -> "
              << "fsm.clusterSize = " << std::dec << fsm.clusterSize << "\n";
  }
};

struct readTime {
  template <class EVT, class FSM, class SourceState, class TargetState>
  void operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    fsm.clusterTime = fsm.data10(fsm.data, fsm.maskIndex);
    --fsm.nof10BitWords;
    ++fsm.maskIndex;
    std::cout << "fsm.data = 0x" << std::hex << fsm.data << " -> "
              << "fsm.time = " << std::dec << fsm.clusterTime << "\n";
  }
};

struct readSample {
  template <class EVT, class FSM, class SourceState, class TargetState>
  void operator()(const EVT& evt, FSM& fsm, SourceState& src, TargetState& tgt)
  {
    auto sample = fsm.data10(fsm.data, fsm.maskIndex);
    if (fsm.maskIndex < fsm.masks.size() - 1) {
      ++fsm.maskIndex;
    }
    --fsm.nof10BitWords;
    std::cout << "fsm.data = 0x" << std::hex << fsm.data
              << " fsm.maskIndex = " << std::dec << fsm.maskIndex << "-> "
              << "sample = " << std::dec << sample << "\n";
  }
};

struct StateMachine_ : public msm::front::state_machine_def<StateMachine_> {
  typedef LookingForSync initial_state;

  struct transition_table : mpl::vector<
                              // clang-format off
  //   Start                Event         Next             Action            Guard
  // +------------------+---------+------------------+---------------------+-------------+
  Row< LookingForSync   , NewData , LookingForHeader , none                , syncFound      >,
  Row< LookingForHeader , NewData , ReadingSize      , none                , validHeader    >,
  Row< ReadingSize      , NewData , ReadingTime      , ActionSequence_
                                                       <mpl::vector<
                                                       saveData,readSize>> , validSize      >,
  Row< ReadingTime      , none    , ReadingSample    , readTime            , none           >,
  Row< ReadingSample    , none    , ReadingSample    , readSample          , moreDataToRead >,
  Row< ReadingSample    , NewData , ReadingSample    , readSample          , moreDataToRead >,
  Row< ReadingSample    , none    , LookingForSync    , readSample          , moreDataToRead >,
                              // clang-format on
                              > {
  };
  // masks used to access groups of 10 bits in a 50 bits range
  uint16_t data10(uint64_t value, int index)
  {
    if (index < 0 || index > 4) {
      std::cout << fmt::format("index {} is out of range\n", index);
      return 0;
    }
    uint64_t m = masks[index];
    return static_cast<uint16_t>(((value & m) >> (4 - index) * 10) & 0x3FF);
  }
  std::array<uint64_t, 5> masks = {0x3FF0000000000, 0xFFC0000000, 0x3FF00000, 0xFFC00, 0x3FF};
  int maskIndex{0};
  uint64_t data{0};
  uint16_t nof10BitWords{0};
  uint16_t clusterSize{0};
  uint16_t clusterTime{0};
};

struct UserLogicDSDecoder::Impl : public msm::back::state_machine<StateMachine_> {
};

UserLogicDSDecoder::UserLogicDSDecoder(uint8_t cruId, uint8_t linkId, SampaChannelHandler sampaChannelHandler, bool chargeSumMode) : mFSM(new UserLogicDSDecoder::Impl)
{
}

void UserLogicDSDecoder::append(uint64_t data)
{
  mFSM->process_event(NewData(data));
}

} // namespace o2::mch::raw
